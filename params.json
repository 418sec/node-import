{"name":"Node-import","tagline":"Imports dependencies and run it directly or concatenate them and exports to file.","body":"Node Import\r\n===========\r\nImports dependencies and run it directly (sync/async) or concatenate them and exports to file.\r\n\r\n## **Why?**\r\n***\r\n\r\nBefore I write this, I just think if I can concatenate my scripts with direct import in each file.\r\nBut when I thinking how to do that, I think I need to create script that can concatenate and run it,\r\nas well supporting synchronus mode without headache.\r\n\r\nBy default, imported scripts executed in synchronus mode, since for async purpose nodejs already have it,\r\neven we have `async` module.\r\n\r\nWe know that asynchronus evented I/O model is the benefits of nodejs. But sometimes, probably we need to runs\r\nsynchronus scripts, especially when we create some modules and we need to separate the files but we need\r\nto ensure each files can communicate with each others, including the global variables in each files.\r\n\r\nNow, you can export the scripts and run it in browser. I mean if you only need to concatenate files\r\nand minify them but still needs namespace for each file. ;)\r\n\r\n\r\n## **Modules**\r\n***\r\n\r\n- `imports()` - Import scripts and run in global context (evaluated scripts will available on all modules) or export to file.\r\n- `imports.module()` - Import scripts and use it inside `module.expors = `. Script will evaulated after module called.\r\n- `include()` - Forwrad `require()` to lookup to all folder, not only inside `node_modules`.\r\n\r\n## **Installation**\r\n***\r\n\r\n```\r\nnpm install --save node-import\r\n```\r\n\r\nTo use the CLI support, install it globally.\r\n\r\n```\r\nnpm install -g node-import\r\n```\r\n\r\nAfter installing the module, import the module in the main file of your script. Module will available in `global` object.\r\nExample:\r\n\r\n`index.js`\r\n\r\n```js\r\nrequire('node-import');\r\n\r\nimports('subdir/file.js');\r\nimports('subdir/another');\r\n```\r\n\r\n## **Include**\r\n***\r\n\r\n`include()` is forwarder for `require()`. Since `require()` only lookup inside `node_modules` folder for simple require,\r\n`include()` will help require to lookup to other location. By default the directory for lookup is `./` or root of project.\r\nYou can define the default location by using `include.location(DIR)`.\r\n \r\n#### Example\r\n \r\n* root\r\n\t - people\r\n\t    - index.js\r\n\t - team\r\n\t    - team.js\r\n\t - index.js\r\n \r\n```js\r\nvar people = include('people');     // Valid\r\nvar team = include('team');         // Valid\r\nvar index = include('index');       // Valid\r\n \r\n```\r\n\r\n## **Import/Export Usage**\r\n### NodeJS\r\n***\r\n\r\n`imports(files, [options (object)]);`\r\n\r\n##### `options`\r\n- `exec` - Execute the imported scripts. Default `true`\r\n- `async` - Execute the imported scripts in async mode. Default `false`\r\n- `export` - Export imported scripts to file. Default `false`\r\n- `exportDir` - Export location.\r\n- `exportMin` - Include minified version when exporting. Default `true`\r\n- `exportMap` - Include sourcemap when uglifying. Default `true` *(not yet tested)*\r\n- `RETURNS` - InlineScript object.\r\n\r\n```js\r\nvar imports = require('node-import');\r\n\r\n// Just execute.\r\nimports('./test.js');\r\n\r\n// Execute and get the scripts.\r\nvar result = imports('./test.js');\r\n\r\n// Write out the result.\r\nfs.writeFile(foofile, result.text, fn);\r\n\r\n// Re-call the script.\r\nresult.run();\r\n\r\n// Only export the scripts.\r\nimports('./test.js', { exec: false, export: true, exportDir: './test/out' });\r\n```\r\n\r\n### NodeJS - In Module\r\n***\r\n\r\n`imports.module(files, [params { wrap: origin }], verbose);`\r\n\r\nThe difference between `imports()` and `imports.module()` is how script loaded.\r\n`imports()` will evaluate the scripts directly, while `imports.module()` is load the scripts but evaluated by module call.\r\n\r\n`imports.module()` also returns `object` contains all global variables in the imported scripts.\r\nLike `require`, but `imports.module()` will export all variables, not only object in `module.exports`.\r\n\r\nE.g: `var mod = require('some-module');`. `imports()` inside `some-module` will evaluated directly as soon as module laoded.\r\nWhile `imports.module()` will evaluated when `mod()` is called.\r\n\r\n##### `Details`\r\n- `files` - Files to import. E.g: `source/main.js`.\r\n- `params` - Object contains paramaters to share with imported scripts. `wrap` is variable name to be used, origin is the original object.\r\n- `verbose` - Show detailed logs.\r\n- `RETURNS` - Object contains variables.\r\n\r\n##### Example in `Gruntfile.js`\r\n\r\n```js\r\nvar imports = require('node-import');\r\n\r\nmodule.expors = function(grunt) {\r\n\t// Importing configs.\r\n\tvar configs = imports.module('./grunt-config/config.js', { loader: grunt });\r\n\t\r\n\t// configs will contains variables from config.js, also from all imported scripts by config.js\r\n\tconsole.log(configs.taskname);\r\n\tconsole.log(configs.taskowner);\r\n};\r\n```\r\n\r\n`grunt-config/config.js`\r\n\r\n```js\r\nvar taskname = 'Test';\r\nvar taskowner = 'Also test';\r\n\r\n// Importing main config and tasks.\r\n'@import task-list.js`;\r\n\r\n// Initializing grunt.\r\n// \"loader\" is equal to \"grunt\" since it's shared by importer above.\r\n// \"config\" is namespace from \"task-list.js\"\r\nloader.initConfig(config);\r\n\r\n// Importing task loader.\r\n'@import task-loader.js`;\r\n```\r\n\r\n\r\n### CLI\r\n***\r\n\r\n`node-import [options] [file ..]`\r\n\r\n##### `options`\r\n- `-r` Run imported scripts. Default `false`\r\n- `-a` Run in async mode. Default `false`\r\n- `-e` Export imported scripts. Default `false`\r\n- `-u` Include uglify when exporting scripts. Default `false`\r\n- `-s` Include sourcemap when uglifying. Default `false`\r\n- `-o` Output directory to export.\r\n- `-v` Logs all processes.\r\n- `-h` Show helps.\r\n\r\n###### **Run**\r\n```\r\n$ node-import -r test/index.js \r\n```\r\n\r\n###### **Export**\r\n```\r\n$ node-import -e -o test/out test/index.js\r\n```\r\n\r\n### **Import/Export**\r\nImport another scripts and run/export to file. Use `$root` as pattern to define as `root` cwd. E.g `@import $root/lib/a.js`.\r\n\r\n#### **Syntax**\r\n***\r\n\r\nUse the `'@import [file ..]';` to import the dependencies. It's should be string, like when you use `use strict`.\r\n\r\n#### **Example**\r\n***\r\n\r\n##### `test.js`\r\n```js\r\n// Importing dependencies at begining.\r\n'@import libs/lib-a.js';\r\n'@import libs/lib-b.js';\r\n\r\nvar a = 'Test..';\r\n\r\n// Create variable from file lib-a.js.\r\nvar b = libaA;\r\n\r\nconsole.log(a, b);\r\n```\r\n\r\n##### `libs/lib-a.js`;\r\n```js\r\n// Create library to be used by test.js\r\nvar libA = 'Foo is bar foobar';\r\n\r\n// Import is not always in begining, and relative to cwd of lib-a.js.\r\n'@import lib-c.js';\r\n\r\n// Imports multiple files.\r\n'@import libs/lib-a.js, libs/lib-c.js';\r\n'@import libs/*.js';\r\n\r\n// Import without file extension.\r\n'@import libs/lib';\r\n'@import libs/lib.config';\r\n```\r\n\r\n## **Namespace**\r\nNamespace provide ability to keep the global variables of file is not overwritten by other references.\r\nNamespace is limited. It's only read `global` variables and should started with new line. E.g\r\n\r\n```js\r\nvar a = 0; // Accepted\r\n\r\nb = 1, c = 3; // Accepted\r\n\r\nif (a = 0) d = 3; // Ignored.\r\n```\r\n\r\n#### **Syntax**\r\n***\r\n\r\nYou can define namespace by using `'@namespace $NAME$';`. Like import, it's should be string as well.\r\n\r\n#### **Example**\r\n***\r\n\r\n##### `foo.js`\r\n```js\r\n// Importing libs.\r\n'@import bar.js';\r\n\r\n// Private vars.\r\nvar myfoo = 'Foo of foo.js';\r\nvar exfoo = bar.foo + myfoo;\r\n\r\n// Global vars.\r\nvar spfoo = foobar + ' is global';\r\n```\r\n\r\n##### `bar.js`\r\n```js\r\n// Create namespace\r\n'@namespace bar';\r\n\r\nvar foo = 'Foo of Bar';\r\nvar foobar = 'Global foobar';\r\n```\r\n\r\n\r\n## **NOTES**\r\n`imports()` is flexible but always evaluate the imported scripts in the `global` context. Be carefull with a words `eval is evil` ;P\r\n`imports.module()` evaluate imported scripts in the NodeImport scope. So it's more safe, but limited to share objects since you need to define `params`.\r\n\r\nMore examples available in `test/` folder. To test it, install the module, cd to the module folder and run `npm test`\r\n\r\n## **Limitation**\r\n***\r\n\r\n* Currently we don't support importing minified javascripts.\r\n* Namespace only read global variables in imported scripts.\r\n* `imports()` run script in `global` context.\r\n* `imports.module()` only share variable in the import result.\r\n* `include()` is just like `require()`, no sharable object in the result.\r\n\r\n## TODO\r\n***\r\n\r\n* Create CLI command `node-import install` to install NPM Packages into any folder, not only `node_modules`. Also `node-import update`.\r\n* Provide support to `imports()` to lookup in default `include` folder.\r\n* Configurations of `imports` and `include` will read the config in file `imports.json`.\r\n\r\n## Release History\r\n***\r\n\r\n* 2015-03-08        v0.6.0      \"Adding include() module\"\r\n* 2015-03-05        v0.5.0      \"Fixing namespace and add return variables as object for imports.module()\"\r\n* 2015-03-05        v0.4.1      \"Fixing source-map sources url mistake.\"\r\n* 2015-03-05        v0.4.0      \"Adding support to import scripts by call it inside a module.\"\r\n* 2015-03-05        v0.3.1      \"Fixing namespace conflict when using null-extension.\"\r\n* 2015-03-05        v0.3.0      \"Adding support to ignore file extension using plain object as namespace.\"\r\n* 2015-02-26        v0.2.1      \"Fixing error defining root\"\r\n* 2015-02-26        v0.2.0      \"Adding namespace constructor to each converted js, to makes namespacing available in browser.\"\r\n* 2015-02-26        v0.1.9      \"Adding $root pattern to define as root cwd.\"\r\n* 2015-02-25        v0.1.8      \"Changing execution context, Fixing Uglify and Sourcemap issue and modifying CLI methods.\"\r\n* 2015-02-25        v0.1.7      \"Adding js-beautify.\"\r\n* 2015-02-25        v0.1.6      \"Fixing namespace and async orders.\"\r\n* 2015-02-24        v0.1.5      \"Fixing bugs with no-exec.\"\r\n* 2015-02-24        v0.1.4      \"Updating namespace variable getter\"\r\n* 2015-02-21        v0.1.3      \"Fixing mistakes with `async` option.\"\r\n* 2015-02-21        v0.1.2      \"Adding namespace support.\"\r\n* 2015-02-21        v0.1.1      \"First release.\"\r\n","google":"UA-59980155-1","note":"Don't delete this file! It's used internally to help with page regeneration."}