{"name":"Node-import","tagline":"Imports dependencies and run it directly or concatenate them and exports to file.","body":"**Node Import**\r\n---\r\n\r\nBefore I write this, I just think if I can concatenate my scripts with direct import in each file.\r\nBut when I thinking how to do that, I think I need to create script that can concatenate and run it,\r\nas well supporting synchronus mode without headache.\r\n\r\nBy default, imported scripts executed in synchronus mode, since for async purpose nodejs already have it,\r\neven we have **`async`** module.\r\n\r\nWe know that asynchronus evented I/O model is the benefits of nodejs. But sometimes, probably we need to runs\r\nsynchronus scripts, especially when we create some modules and we need to separate the files but we need\r\nto ensure each files can communicate with each others, including the global variables in each files.\r\n\r\nNow, you can export the scripts and run it in browser. I mean if you only need to concatenate files\r\nand minify them but still needs namespace for each file. ;)\r\n\r\n***\r\n**Is it usefull?**\r\n```javascript\r\n// Import another files.\r\n'@import foo.js';\r\n'@import config';\r\n\r\n// Read variable from other files.\r\nconsole.log(foo.title);\r\n\r\n// Create namespace.\r\n'@namespace bar';\r\n\r\n// This variable will available in the namespace => bar.tilte.\r\nvar title = 'Title of Bar';\r\n```\r\n\r\n***\r\n### **`Installation`**\r\n---\r\n```\r\nnpm install --save node-import\r\n```\r\n\r\nTo use the CLI support, install it globally.\r\n\r\n```\r\nnpm install -g node-import\r\n```\r\n\r\n---\r\nAfter installing the module, you can load the module in the main file of your script. Module will available in\r\n**`global`** object.\r\n\r\n**Example**\r\n```js\r\n// Load node-import without wrapping to variable.\r\nrequire('node-import');\r\n\r\n// After node-import loaded, all methods will available in global scope.\r\ninclude('foo');\r\nimports('bar/main');\r\n```\r\n\r\n***\r\n### **`include()`**\r\n\r\nInclude **`modules`** from outside **`node_modules`** folder. Since the default **`require()`** is only \r\naccess the **`node_modules`** folder, **`include()`** will help us to require modules or json from any folder.\r\nIt's works like **`require()`**.\r\n\r\n**Usage**\r\n```javascript\r\nvar foo = include(SCRIPTS);\r\n```\r\n\r\n---\r\n**Params**\r\n\r\n| **Name** | **Type** | **Description** |\r\n| -------- | -------- | --------------- |\r\n| SCRIPTS | `String` | String module name, folder name, or js/json filename. |\r\n\r\n***\r\n**Example**\r\n\r\n- **root**\r\n\t - **people**\r\n\t    - **`index.js`**\r\n\t - **team**\r\n\t    - **support**\r\n\t        - **`main.js`**\r\n\t        - **`package.json`**\r\n\t    - **`team.js`**\r\n\t - **`index.js`**\r\n\t \r\n```javascript\r\n// Load the node-import first.\r\nrequire('node-import');\r\n\r\n// Include people.\r\nvar people = include('people');     // Valid\r\n\r\n// Equal with\r\nvar people = require('./people/index.js');\r\n\r\n// Other\r\nvar team = include('team');         // Valid\r\nvar index = include('index');       // Valid\r\n\r\n// Include package. It's valid with `main` property defined.\r\nvar support = include('support');   // In package.json, `main` property referenced to `main.js`\r\n```\r\n\r\n***\r\n### **`imports()`**\r\n\r\nImport/Export scripts.\r\nYou can load scripts from file and run it to global scope.\r\nAll variables in the scripts will available to another scripts.\r\nImports will always run the scripts in global scope, so using it in the **`module.exports = `** block sometimes will not works properly.\r\nNodeImport provide **`$root`** pattern to add root folder to the filename.\r\n\r\n**Usage**\r\n```javascript\r\nvar script = imports(FILES, OPTIONS);\r\n```\r\n\r\n**Returns: `script object`**\r\n\r\n---\r\n**Params**\r\n\r\n| **Name** | **Type** | **Description** |\r\n| -------- | -------- | --------------- |\r\n| FILES | `String` or `Array` | Script filename or array filename lists. You can ignore the file extension. Add `$root` in the filename as root folder. |\r\n| OPTIONS `optional` | `Object` | Object contains the import options. |\r\n\r\n---\r\n**Options**\r\n\r\nRemember, options name is case-sencitive.\r\n\r\n| **Name** | **Type** | **Default** | **Description** |\r\n| -------- | -------- | ----------- | --------------- |\r\n| exec | `Boolean` | `true` | Run the imported scripts or not. |\r\n| async | `Boolean` | `false` | Run the imported scripts in `async` mode or not. |\r\n| export | `Boolean` | `false` | Export the imported scripts to file or not. |\r\n| exportDir | `String` | `null` | Folder location to save the imported scripts. |\r\n| exportMin | `Boolean` | `true` | Also save the minified version when exporting scripts. |\r\n| exportMap | `Boolean` | `true` | Also save the sourcemap file when exporting scripts. |\r\n\r\n---\r\n**Example**\r\n```javascript\r\n// Load the node-import first.\r\nrequire('node-import');\r\n\r\n// Imports foo.js file and run it.\r\nvar foo = imports('foo/main');\r\n\r\n// Re-run the imported scripts.\r\nfoo.run();\r\n\r\n// Print the imported scripts.\r\nconsole.log(foo.text);\r\n\r\n// Only export the scripts.\r\nimports('foo/extra', { exec: false, export: true, exportDir: 'test/out' });\r\n```\r\n\r\n***\r\n### **`imports.module()`**\r\n\r\nImport scripts inside **`module.exports`** block. The difference with **`imports()`** is the scripts will be\r\nevaluated when the module is used. While **`imports()`** is evaluated directly into global scope.\r\n\r\nImported scripts using **`import.module()`** will be evaluated in the **`node-import`** scope, so it's safe.\r\nThe benefit is the result will contains all global variables in the imported scripts. While **`require()`** will only\r\ncontains exported module.\r\n\r\n**Usage**\r\n```javascript\r\nvar result = imports(FILES, SHARED_VARIABLES);\r\n```\r\n\r\n---\r\n**Params**\r\n\r\n| **Name** | **Type** | **Description** |\r\n| -------- | -------- | --------------- |\r\n| FILES | `String` or `Array` | Script filename or array filename lists. You can ignore the file extension. |\r\n| SHARED_VARIABLES `optional` | `Object` | Object contains variables to share with imported scripts. |\r\n\r\n---\r\n**Example**\r\n```js\r\n// Load node-import first.\r\nrequire('node-import');\r\n\r\nmodule.expors = function(param) {\r\n\t// Importing foo.js and share parameters with imported scripts.\r\n\tvar foo = imports.module('foo/main', { shared: param });\r\n\t\r\n\t// foo contains the global variables from foo.js\r\n\tconsole.log(foo.title);\r\n\tconsole.log(foo.description);\r\n};\r\n```\r\n\r\n**`foo/main.js`**\r\n\r\n```js\r\n// Create variables to share to result.\r\nvar title = 'Foo title';\r\nvar description = 'The foo is a non-bar string and always be foo';\r\n\r\n// Read the shared variables from the importer.\r\nconsole.log(shared);\r\n```\r\n\r\n***\r\n### **`@import`**\r\n\r\nThis is pattern to import another scripts and require to be loaded by **`imports()`** or **`imports.module()`**.\r\nThe pattern options will follow the **`imports()`** or **`imports.module()`** options.\r\n\r\n**Usage**\r\n\r\nThe pattern must be defined using string. Like when we use **`'use strict';`**.\r\n\r\n```javascript\r\n'@import [FILES ...]';\r\n\r\n// Do something with imported scripts.\r\n```\r\n\r\n---\r\n**Params**\r\n\r\n| **Name** | **Type** | **Description** |\r\n| -------- | -------- | --------------- |\r\n| FILES | `String` | File name with extension, file name without extension, folder name or comma separated file names. |\r\n\r\n---\r\n**Example**\r\n\r\n**`test.js`**\r\n```js\r\n// Load node-import first.\r\nrequire('node-import');\r\n\r\n// Importing importing lib-a.js using imports() since pattern wont works without this importer in the main script.\r\nimports('libs/lib-a');\r\n\r\n// Access the variables from imported scripts.\r\nconsole.log(title); // > Title from lib-a.js\r\nconsole.log(description); // > Description from lib-a.js\r\n\r\n// Replace the title\r\ntitle = 'Replaced title';\r\n\r\n// Print the title\r\nconsole.log(title); // > Replaced title\r\n```\r\n\r\n**`libs/lib-a.js`**\r\n```js\r\n// Import another file at begining.\r\n'@import lib-b.js';\r\n\r\n// Create variables to share it.\r\nvar title = 'Title from lib-a.js';\r\nvar description = 'Description from lib-a.js';\r\n\r\n// Import is not always at begining, and relative to the last working directory.\r\n'@import lib-c.js';\r\n\r\n// Imports multiple files with comma separated.\r\n'@import libs/lib-d.js, libs/lib-e.js';\r\n\r\n// Import without file extension.\r\n'@import libs/code'; // If folder contains code.a.js or code.b.js it's will be imported as well.\r\n\r\n// Import all files inside folder. *.js is important!\r\n'@import libs/configs/*.js';\r\n```\r\n\r\n***\r\n### **`@namespace`**\r\n\r\nNamespace is pattern to makes the variables in the imported file will available as **`public`** and **`private`**.\r\nIt's mean when you have variables with same name, variable inside the namespace will not replaced by next changes.\r\n\r\n**Usage**\r\n```javascript\r\n'@namespace NAME';\r\n\r\n// Do anythings.\r\n```\r\n\r\n---\r\n**Params**\r\n\r\n| **Name** | **Type** | **Description** |\r\n| -------- | -------- | --------------- |\r\n| NAME | `String` | Namespace name. It's will be used when you access the namespace. |\r\n\r\n---\r\n**Example**\r\n```javascript\r\n// Importing namespaces.\r\n'@import foo';\r\n'@import bar';\r\n\r\n// The public title is title of bar since title from foo is replaced by title from bar.\r\nconsole.log(title); // > Title of Bar.\r\n\r\n// Print the title of foo. Since it's in namespace, it wont be replaced by title from bar.\r\nconsole.log(foo.title); // Title of Foo\r\n\r\n// Print the title of bar.\r\nconsole.log(bar.title); // Title of Bar.\r\n\r\n// Print the public variables from foo and bar.\r\nconsole.log(fooA, barA); // > A from foo A from Bar\r\n```\r\n\r\n**`foo.js`**\r\n```javascript\r\n'@namespace foo';\r\n\r\nvar title = 'Title of Foo';\r\nvar fooA = 'A from foo';\r\n```\r\n\r\n**`bar.js`**\r\n```javascript\r\n'@namespace bar';\r\n\r\nvar title = 'Title of Bar';\r\nvar barA = 'A from Bar';\r\n\r\n// Saved variables is everythings that outside any block. You can define the variable with/without \"var\".\r\nvar barC = 'C from Bar'; // Saved to namespace.\r\n\r\nbarD = 'D from Bar'; // Saved to namespace.\r\n\r\nvar barE = 'E from Bar', barF = 'F from Bar'; // Saved to namespace.\r\n\r\nfunction bars() {\r\n    var barG = 'Bar in function'; // Not saved to namespace.\r\n}\r\n\r\nif ('undefined' === typeof global) {\r\n    var barH = 'Bar in block'; // Not saved to namespace.\r\n}\r\n```\r\n\r\n***\r\n### **`node-import` CLI** \r\n\r\nUse node-import in the command line.\r\n\r\n**Usage**\r\n```\r\nnode-import [options] [file ..]\r\n```\r\n\r\n---\r\n**options**\r\n- `-r` Run imported scripts. Default `false`\r\n- `-a` Run in async mode. Default `false`\r\n- `-e` Export imported scripts. Default `false`\r\n- `-u` Include uglify when exporting scripts. Default `false`\r\n- `-s` Include sourcemap when uglifying. Default `false`\r\n- `-o` Output directory to export.\r\n- `-v` Logs all processes.\r\n- `-h` Show helps.\r\n\r\n**Example**\r\n###### **Run**\r\n```\r\n$ node-import -r test/index.js \r\n```\r\n\r\n---\r\n###### **Export**\r\n```\r\n$ node-import -e -o test/out test/index.js\r\n```\r\n\r\n***\r\n### **`NOTES`**\r\nMore examples available in **`test/`** folder.\r\nTo test it, install the module, cd to the module folder and run **`npm test`**\r\n\r\n***\r\n### **`Limitation`**\r\n\r\n* Currently we don't support importing minified javascripts.\r\n* Namespace only read global variables in imported scripts.\r\n* `imports()` run script in `global` context.\r\n* `imports.module()` only share variable in the import result.\r\n* `include()` is just like `require()`, no sharable object in the result.\r\n\r\n***\r\n### **`TODO`**\r\n\r\n* Create CLI command `node-import install` to install NPM Packages into any folder, not only `node_modules`. Also `node-import update`.\r\n* Provide support to `imports()` to lookup in default `include` folder.\r\n* Configurations of `imports` and `include` will read the config in file `imports.json`.\r\n\r\n***\r\n### **`Release History`**\r\n\r\n* 2015-03-22        v0.6.1      \"Improving Readme\"\r\n* 2015-03-08        v0.6.0      \"Adding include() module\"\r\n* 2015-03-05        v0.5.0      \"Fixing namespace and add return variables as object for imports.module()\"\r\n* 2015-03-05        v0.4.1      \"Fixing source-map sources url mistake.\"\r\n* 2015-03-05        v0.4.0      \"Adding support to import scripts by call it inside a module.\"\r\n* 2015-03-05        v0.3.1      \"Fixing namespace conflict when using null-extension.\"\r\n* 2015-03-05        v0.3.0      \"Adding support to ignore file extension using plain object as namespace.\"\r\n* 2015-02-26        v0.2.1      \"Fixing error defining root\"\r\n* 2015-02-26        v0.2.0      \"Adding namespace constructor to each converted js, to makes namespacing available in browser.\"\r\n* 2015-02-26        v0.1.9      \"Adding $root pattern to define as root cwd.\"\r\n* 2015-02-25        v0.1.8      \"Changing execution context, Fixing Uglify and Sourcemap issue and modifying CLI methods.\"\r\n* 2015-02-25        v0.1.7      \"Adding js-beautify.\"\r\n* 2015-02-25        v0.1.6      \"Fixing namespace and async orders.\"\r\n* 2015-02-24        v0.1.5      \"Fixing bugs with no-exec.\"\r\n* 2015-02-24        v0.1.4      \"Updating namespace variable getter\"\r\n* 2015-02-21        v0.1.3      \"Fixing mistakes with `async` option.\"\r\n* 2015-02-21        v0.1.2      \"Adding namespace support.\"\r\n* 2015-02-21        v0.1.1      \"First release.\"","google":"UA-59980155-1","note":"Don't delete this file! It's used internally to help with page regeneration."}